// <auto-generated>
// This code was generated by a tool.
// </auto-generated>

using System;
using System.Collections.Generic;
using System.Data;
using System.Threading.Tasks;
using Dapper;

namespace HQ.Data.Sql.Dapper
{
    /// <summary>
    /// Multi-mapping extensions for Dapper. Note that Dapper has a six-clause mapping limitation.
    /// </summary>
    public static partial class DapperExtensions
    {
        public static IEnumerable<TParent> QueryM<TParent, TChild1, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Func<TParent, IList<TChild1>> child1Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            connection.Query<TParent, TChild1, TParent>(sql, (parent, child1) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent).Add(child1);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static async Task<IEnumerable<TParent>> QueryMAsync<TParent, TChild1, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Func<TParent, IList<TChild1>> child1Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            await connection.QueryAsync<TParent, TChild1, TParent>(sql, (parent, child1) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent).Add(child1);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static IEnumerable<TParent> QueryO<TParent, TChild1, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Action<TParent, TChild1> child1Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            connection.Query<TParent, TChild1, TParent>(sql, (parent, child1) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent, child1);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static async Task<IEnumerable<TParent>> QueryOAsync<TParent, TChild1, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Action<TParent, TChild1> child1Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            await connection.QueryAsync<TParent, TChild1, TParent>(sql, (parent, child1) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent, child1);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static IEnumerable<TParent> QueryMM<TParent, TChild1, TChild2, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Func<TParent, IList<TChild1>> child1Setter,
            Func<TParent, IList<TChild2>> child2Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            connection.Query<TParent, TChild1, TChild2, TParent>(sql, (parent, child1, child2) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent).Add(child1);
                child2Setter(cachedParent).Add(child2);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static async Task<IEnumerable<TParent>> QueryMMAsync<TParent, TChild1, TChild2, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Func<TParent, IList<TChild1>> child1Setter,
            Func<TParent, IList<TChild2>> child2Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            await connection.QueryAsync<TParent, TChild1, TChild2, TParent>(sql, (parent, child1, child2) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent).Add(child1);
                child2Setter(cachedParent).Add(child2);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static IEnumerable<TParent> QueryOM<TParent, TChild1, TChild2, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Action<TParent, TChild1> child1Setter,
            Func<TParent, IList<TChild2>> child2Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            connection.Query<TParent, TChild1, TChild2, TParent>(sql, (parent, child1, child2) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent, child1);
                child2Setter(cachedParent).Add(child2);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static async Task<IEnumerable<TParent>> QueryOMAsync<TParent, TChild1, TChild2, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Action<TParent, TChild1> child1Setter,
            Func<TParent, IList<TChild2>> child2Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            await connection.QueryAsync<TParent, TChild1, TChild2, TParent>(sql, (parent, child1, child2) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent, child1);
                child2Setter(cachedParent).Add(child2);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static IEnumerable<TParent> QueryOO<TParent, TChild1, TChild2, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Action<TParent, TChild1> child1Setter,
            Action<TParent, TChild2> child2Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            connection.Query<TParent, TChild1, TChild2, TParent>(sql, (parent, child1, child2) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent, child1);
                child2Setter(cachedParent, child2);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static async Task<IEnumerable<TParent>> QueryOOAsync<TParent, TChild1, TChild2, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Action<TParent, TChild1> child1Setter,
            Action<TParent, TChild2> child2Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            await connection.QueryAsync<TParent, TChild1, TChild2, TParent>(sql, (parent, child1, child2) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent, child1);
                child2Setter(cachedParent, child2);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static IEnumerable<TParent> QueryMMM<TParent, TChild1, TChild2, TChild3, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Func<TParent, IList<TChild1>> child1Setter,
            Func<TParent, IList<TChild2>> child2Setter,
            Func<TParent, IList<TChild3>> child3Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            connection.Query<TParent, TChild1, TChild2, TChild3, TParent>(sql, (parent, child1, child2, child3) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent).Add(child1);
                child2Setter(cachedParent).Add(child2);
                child3Setter(cachedParent).Add(child3);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static async Task<IEnumerable<TParent>> QueryMMMAsync<TParent, TChild1, TChild2, TChild3, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Func<TParent, IList<TChild1>> child1Setter,
            Func<TParent, IList<TChild2>> child2Setter,
            Func<TParent, IList<TChild3>> child3Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            await connection.QueryAsync<TParent, TChild1, TChild2, TChild3, TParent>(sql, (parent, child1, child2, child3) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent).Add(child1);
                child2Setter(cachedParent).Add(child2);
                child3Setter(cachedParent).Add(child3);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static IEnumerable<TParent> QueryOMM<TParent, TChild1, TChild2, TChild3, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Action<TParent, TChild1> child1Setter,
            Func<TParent, IList<TChild2>> child2Setter,
            Func<TParent, IList<TChild3>> child3Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            connection.Query<TParent, TChild1, TChild2, TChild3, TParent>(sql, (parent, child1, child2, child3) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent, child1);
                child2Setter(cachedParent).Add(child2);
                child3Setter(cachedParent).Add(child3);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static async Task<IEnumerable<TParent>> QueryOMMAsync<TParent, TChild1, TChild2, TChild3, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Action<TParent, TChild1> child1Setter,
            Func<TParent, IList<TChild2>> child2Setter,
            Func<TParent, IList<TChild3>> child3Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            await connection.QueryAsync<TParent, TChild1, TChild2, TChild3, TParent>(sql, (parent, child1, child2, child3) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent, child1);
                child2Setter(cachedParent).Add(child2);
                child3Setter(cachedParent).Add(child3);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static IEnumerable<TParent> QueryOOM<TParent, TChild1, TChild2, TChild3, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Action<TParent, TChild1> child1Setter,
            Action<TParent, TChild2> child2Setter,
            Func<TParent, IList<TChild3>> child3Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            connection.Query<TParent, TChild1, TChild2, TChild3, TParent>(sql, (parent, child1, child2, child3) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent, child1);
                child2Setter(cachedParent, child2);
                child3Setter(cachedParent).Add(child3);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static async Task<IEnumerable<TParent>> QueryOOMAsync<TParent, TChild1, TChild2, TChild3, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Action<TParent, TChild1> child1Setter,
            Action<TParent, TChild2> child2Setter,
            Func<TParent, IList<TChild3>> child3Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            await connection.QueryAsync<TParent, TChild1, TChild2, TChild3, TParent>(sql, (parent, child1, child2, child3) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent, child1);
                child2Setter(cachedParent, child2);
                child3Setter(cachedParent).Add(child3);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static IEnumerable<TParent> QueryOOO<TParent, TChild1, TChild2, TChild3, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Action<TParent, TChild1> child1Setter,
            Action<TParent, TChild2> child2Setter,
            Action<TParent, TChild3> child3Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            connection.Query<TParent, TChild1, TChild2, TChild3, TParent>(sql, (parent, child1, child2, child3) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent, child1);
                child2Setter(cachedParent, child2);
                child3Setter(cachedParent, child3);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static async Task<IEnumerable<TParent>> QueryOOOAsync<TParent, TChild1, TChild2, TChild3, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Action<TParent, TChild1> child1Setter,
            Action<TParent, TChild2> child2Setter,
            Action<TParent, TChild3> child3Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            await connection.QueryAsync<TParent, TChild1, TChild2, TChild3, TParent>(sql, (parent, child1, child2, child3) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent, child1);
                child2Setter(cachedParent, child2);
                child3Setter(cachedParent, child3);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static IEnumerable<TParent> QueryMMMM<TParent, TChild1, TChild2, TChild3, TChild4, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Func<TParent, IList<TChild1>> child1Setter,
            Func<TParent, IList<TChild2>> child2Setter,
            Func<TParent, IList<TChild3>> child3Setter,
            Func<TParent, IList<TChild4>> child4Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            connection.Query<TParent, TChild1, TChild2, TChild3, TChild4, TParent>(sql, (parent, child1, child2, child3, child4) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent).Add(child1);
                child2Setter(cachedParent).Add(child2);
                child3Setter(cachedParent).Add(child3);
                child4Setter(cachedParent).Add(child4);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static async Task<IEnumerable<TParent>> QueryMMMMAsync<TParent, TChild1, TChild2, TChild3, TChild4, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Func<TParent, IList<TChild1>> child1Setter,
            Func<TParent, IList<TChild2>> child2Setter,
            Func<TParent, IList<TChild3>> child3Setter,
            Func<TParent, IList<TChild4>> child4Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            await connection.QueryAsync<TParent, TChild1, TChild2, TChild3, TChild4, TParent>(sql, (parent, child1, child2, child3, child4) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent).Add(child1);
                child2Setter(cachedParent).Add(child2);
                child3Setter(cachedParent).Add(child3);
                child4Setter(cachedParent).Add(child4);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static IEnumerable<TParent> QueryOMMM<TParent, TChild1, TChild2, TChild3, TChild4, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Action<TParent, TChild1> child1Setter,
            Func<TParent, IList<TChild2>> child2Setter,
            Func<TParent, IList<TChild3>> child3Setter,
            Func<TParent, IList<TChild4>> child4Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            connection.Query<TParent, TChild1, TChild2, TChild3, TChild4, TParent>(sql, (parent, child1, child2, child3, child4) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent, child1);
                child2Setter(cachedParent).Add(child2);
                child3Setter(cachedParent).Add(child3);
                child4Setter(cachedParent).Add(child4);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static async Task<IEnumerable<TParent>> QueryOMMMAsync<TParent, TChild1, TChild2, TChild3, TChild4, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Action<TParent, TChild1> child1Setter,
            Func<TParent, IList<TChild2>> child2Setter,
            Func<TParent, IList<TChild3>> child3Setter,
            Func<TParent, IList<TChild4>> child4Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            await connection.QueryAsync<TParent, TChild1, TChild2, TChild3, TChild4, TParent>(sql, (parent, child1, child2, child3, child4) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent, child1);
                child2Setter(cachedParent).Add(child2);
                child3Setter(cachedParent).Add(child3);
                child4Setter(cachedParent).Add(child4);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static IEnumerable<TParent> QueryOOMM<TParent, TChild1, TChild2, TChild3, TChild4, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Action<TParent, TChild1> child1Setter,
            Action<TParent, TChild2> child2Setter,
            Func<TParent, IList<TChild3>> child3Setter,
            Func<TParent, IList<TChild4>> child4Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            connection.Query<TParent, TChild1, TChild2, TChild3, TChild4, TParent>(sql, (parent, child1, child2, child3, child4) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent, child1);
                child2Setter(cachedParent, child2);
                child3Setter(cachedParent).Add(child3);
                child4Setter(cachedParent).Add(child4);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static async Task<IEnumerable<TParent>> QueryOOMMAsync<TParent, TChild1, TChild2, TChild3, TChild4, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Action<TParent, TChild1> child1Setter,
            Action<TParent, TChild2> child2Setter,
            Func<TParent, IList<TChild3>> child3Setter,
            Func<TParent, IList<TChild4>> child4Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            await connection.QueryAsync<TParent, TChild1, TChild2, TChild3, TChild4, TParent>(sql, (parent, child1, child2, child3, child4) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent, child1);
                child2Setter(cachedParent, child2);
                child3Setter(cachedParent).Add(child3);
                child4Setter(cachedParent).Add(child4);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static IEnumerable<TParent> QueryOOOM<TParent, TChild1, TChild2, TChild3, TChild4, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Action<TParent, TChild1> child1Setter,
            Action<TParent, TChild2> child2Setter,
            Action<TParent, TChild3> child3Setter,
            Func<TParent, IList<TChild4>> child4Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            connection.Query<TParent, TChild1, TChild2, TChild3, TChild4, TParent>(sql, (parent, child1, child2, child3, child4) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent, child1);
                child2Setter(cachedParent, child2);
                child3Setter(cachedParent, child3);
                child4Setter(cachedParent).Add(child4);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static async Task<IEnumerable<TParent>> QueryOOOMAsync<TParent, TChild1, TChild2, TChild3, TChild4, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Action<TParent, TChild1> child1Setter,
            Action<TParent, TChild2> child2Setter,
            Action<TParent, TChild3> child3Setter,
            Func<TParent, IList<TChild4>> child4Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            await connection.QueryAsync<TParent, TChild1, TChild2, TChild3, TChild4, TParent>(sql, (parent, child1, child2, child3, child4) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent, child1);
                child2Setter(cachedParent, child2);
                child3Setter(cachedParent, child3);
                child4Setter(cachedParent).Add(child4);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static IEnumerable<TParent> QueryOOOO<TParent, TChild1, TChild2, TChild3, TChild4, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Action<TParent, TChild1> child1Setter,
            Action<TParent, TChild2> child2Setter,
            Action<TParent, TChild3> child3Setter,
            Action<TParent, TChild4> child4Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            connection.Query<TParent, TChild1, TChild2, TChild3, TChild4, TParent>(sql, (parent, child1, child2, child3, child4) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent, child1);
                child2Setter(cachedParent, child2);
                child3Setter(cachedParent, child3);
                child4Setter(cachedParent, child4);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static async Task<IEnumerable<TParent>> QueryOOOOAsync<TParent, TChild1, TChild2, TChild3, TChild4, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Action<TParent, TChild1> child1Setter,
            Action<TParent, TChild2> child2Setter,
            Action<TParent, TChild3> child3Setter,
            Action<TParent, TChild4> child4Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            await connection.QueryAsync<TParent, TChild1, TChild2, TChild3, TChild4, TParent>(sql, (parent, child1, child2, child3, child4) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent, child1);
                child2Setter(cachedParent, child2);
                child3Setter(cachedParent, child3);
                child4Setter(cachedParent, child4);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static IEnumerable<TParent> QueryMMMMM<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Func<TParent, IList<TChild1>> child1Setter,
            Func<TParent, IList<TChild2>> child2Setter,
            Func<TParent, IList<TChild3>> child3Setter,
            Func<TParent, IList<TChild4>> child4Setter,
            Func<TParent, IList<TChild5>> child5Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            connection.Query<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TParent>(sql, (parent, child1, child2, child3, child4, child5) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent).Add(child1);
                child2Setter(cachedParent).Add(child2);
                child3Setter(cachedParent).Add(child3);
                child4Setter(cachedParent).Add(child4);
                child5Setter(cachedParent).Add(child5);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static async Task<IEnumerable<TParent>> QueryMMMMMAsync<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Func<TParent, IList<TChild1>> child1Setter,
            Func<TParent, IList<TChild2>> child2Setter,
            Func<TParent, IList<TChild3>> child3Setter,
            Func<TParent, IList<TChild4>> child4Setter,
            Func<TParent, IList<TChild5>> child5Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            await connection.QueryAsync<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TParent>(sql, (parent, child1, child2, child3, child4, child5) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent).Add(child1);
                child2Setter(cachedParent).Add(child2);
                child3Setter(cachedParent).Add(child3);
                child4Setter(cachedParent).Add(child4);
                child5Setter(cachedParent).Add(child5);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static IEnumerable<TParent> QueryOMMMM<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Action<TParent, TChild1> child1Setter,
            Func<TParent, IList<TChild2>> child2Setter,
            Func<TParent, IList<TChild3>> child3Setter,
            Func<TParent, IList<TChild4>> child4Setter,
            Func<TParent, IList<TChild5>> child5Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            connection.Query<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TParent>(sql, (parent, child1, child2, child3, child4, child5) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent, child1);
                child2Setter(cachedParent).Add(child2);
                child3Setter(cachedParent).Add(child3);
                child4Setter(cachedParent).Add(child4);
                child5Setter(cachedParent).Add(child5);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static async Task<IEnumerable<TParent>> QueryOMMMMAsync<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Action<TParent, TChild1> child1Setter,
            Func<TParent, IList<TChild2>> child2Setter,
            Func<TParent, IList<TChild3>> child3Setter,
            Func<TParent, IList<TChild4>> child4Setter,
            Func<TParent, IList<TChild5>> child5Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            await connection.QueryAsync<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TParent>(sql, (parent, child1, child2, child3, child4, child5) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent, child1);
                child2Setter(cachedParent).Add(child2);
                child3Setter(cachedParent).Add(child3);
                child4Setter(cachedParent).Add(child4);
                child5Setter(cachedParent).Add(child5);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static IEnumerable<TParent> QueryOOMMM<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Action<TParent, TChild1> child1Setter,
            Action<TParent, TChild2> child2Setter,
            Func<TParent, IList<TChild3>> child3Setter,
            Func<TParent, IList<TChild4>> child4Setter,
            Func<TParent, IList<TChild5>> child5Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            connection.Query<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TParent>(sql, (parent, child1, child2, child3, child4, child5) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent, child1);
                child2Setter(cachedParent, child2);
                child3Setter(cachedParent).Add(child3);
                child4Setter(cachedParent).Add(child4);
                child5Setter(cachedParent).Add(child5);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static async Task<IEnumerable<TParent>> QueryOOMMMAsync<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Action<TParent, TChild1> child1Setter,
            Action<TParent, TChild2> child2Setter,
            Func<TParent, IList<TChild3>> child3Setter,
            Func<TParent, IList<TChild4>> child4Setter,
            Func<TParent, IList<TChild5>> child5Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            await connection.QueryAsync<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TParent>(sql, (parent, child1, child2, child3, child4, child5) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent, child1);
                child2Setter(cachedParent, child2);
                child3Setter(cachedParent).Add(child3);
                child4Setter(cachedParent).Add(child4);
                child5Setter(cachedParent).Add(child5);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static IEnumerable<TParent> QueryOOOMM<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Action<TParent, TChild1> child1Setter,
            Action<TParent, TChild2> child2Setter,
            Action<TParent, TChild3> child3Setter,
            Func<TParent, IList<TChild4>> child4Setter,
            Func<TParent, IList<TChild5>> child5Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            connection.Query<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TParent>(sql, (parent, child1, child2, child3, child4, child5) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent, child1);
                child2Setter(cachedParent, child2);
                child3Setter(cachedParent, child3);
                child4Setter(cachedParent).Add(child4);
                child5Setter(cachedParent).Add(child5);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static async Task<IEnumerable<TParent>> QueryOOOMMAsync<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Action<TParent, TChild1> child1Setter,
            Action<TParent, TChild2> child2Setter,
            Action<TParent, TChild3> child3Setter,
            Func<TParent, IList<TChild4>> child4Setter,
            Func<TParent, IList<TChild5>> child5Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            await connection.QueryAsync<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TParent>(sql, (parent, child1, child2, child3, child4, child5) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent, child1);
                child2Setter(cachedParent, child2);
                child3Setter(cachedParent, child3);
                child4Setter(cachedParent).Add(child4);
                child5Setter(cachedParent).Add(child5);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static IEnumerable<TParent> QueryOOOOM<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Action<TParent, TChild1> child1Setter,
            Action<TParent, TChild2> child2Setter,
            Action<TParent, TChild3> child3Setter,
            Action<TParent, TChild4> child4Setter,
            Func<TParent, IList<TChild5>> child5Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            connection.Query<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TParent>(sql, (parent, child1, child2, child3, child4, child5) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent, child1);
                child2Setter(cachedParent, child2);
                child3Setter(cachedParent, child3);
                child4Setter(cachedParent, child4);
                child5Setter(cachedParent).Add(child5);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static async Task<IEnumerable<TParent>> QueryOOOOMAsync<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Action<TParent, TChild1> child1Setter,
            Action<TParent, TChild2> child2Setter,
            Action<TParent, TChild3> child3Setter,
            Action<TParent, TChild4> child4Setter,
            Func<TParent, IList<TChild5>> child5Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            await connection.QueryAsync<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TParent>(sql, (parent, child1, child2, child3, child4, child5) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent, child1);
                child2Setter(cachedParent, child2);
                child3Setter(cachedParent, child3);
                child4Setter(cachedParent, child4);
                child5Setter(cachedParent).Add(child5);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static IEnumerable<TParent> QueryOOOOO<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Action<TParent, TChild1> child1Setter,
            Action<TParent, TChild2> child2Setter,
            Action<TParent, TChild3> child3Setter,
            Action<TParent, TChild4> child4Setter,
            Action<TParent, TChild5> child5Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            connection.Query<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TParent>(sql, (parent, child1, child2, child3, child4, child5) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent, child1);
                child2Setter(cachedParent, child2);
                child3Setter(cachedParent, child3);
                child4Setter(cachedParent, child4);
                child5Setter(cachedParent, child5);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static async Task<IEnumerable<TParent>> QueryOOOOOAsync<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Action<TParent, TChild1> child1Setter,
            Action<TParent, TChild2> child2Setter,
            Action<TParent, TChild3> child3Setter,
            Action<TParent, TChild4> child4Setter,
            Action<TParent, TChild5> child5Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            await connection.QueryAsync<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TParent>(sql, (parent, child1, child2, child3, child4, child5) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent, child1);
                child2Setter(cachedParent, child2);
                child3Setter(cachedParent, child3);
                child4Setter(cachedParent, child4);
                child5Setter(cachedParent, child5);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static IEnumerable<TParent> QueryMMMMMM<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TChild6, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Func<TParent, IList<TChild1>> child1Setter,
            Func<TParent, IList<TChild2>> child2Setter,
            Func<TParent, IList<TChild3>> child3Setter,
            Func<TParent, IList<TChild4>> child4Setter,
            Func<TParent, IList<TChild5>> child5Setter,
            Func<TParent, IList<TChild6>> child6Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            connection.Query<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TChild6, TParent>(sql, (parent, child1, child2, child3, child4, child5, child6) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent).Add(child1);
                child2Setter(cachedParent).Add(child2);
                child3Setter(cachedParent).Add(child3);
                child4Setter(cachedParent).Add(child4);
                child5Setter(cachedParent).Add(child5);
                child6Setter(cachedParent).Add(child6);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static async Task<IEnumerable<TParent>> QueryMMMMMMAsync<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TChild6, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Func<TParent, IList<TChild1>> child1Setter,
            Func<TParent, IList<TChild2>> child2Setter,
            Func<TParent, IList<TChild3>> child3Setter,
            Func<TParent, IList<TChild4>> child4Setter,
            Func<TParent, IList<TChild5>> child5Setter,
            Func<TParent, IList<TChild6>> child6Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            await connection.QueryAsync<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TChild6, TParent>(sql, (parent, child1, child2, child3, child4, child5, child6) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent).Add(child1);
                child2Setter(cachedParent).Add(child2);
                child3Setter(cachedParent).Add(child3);
                child4Setter(cachedParent).Add(child4);
                child5Setter(cachedParent).Add(child5);
                child6Setter(cachedParent).Add(child6);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static IEnumerable<TParent> QueryOMMMMM<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TChild6, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Action<TParent, TChild1> child1Setter,
            Func<TParent, IList<TChild2>> child2Setter,
            Func<TParent, IList<TChild3>> child3Setter,
            Func<TParent, IList<TChild4>> child4Setter,
            Func<TParent, IList<TChild5>> child5Setter,
            Func<TParent, IList<TChild6>> child6Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            connection.Query<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TChild6, TParent>(sql, (parent, child1, child2, child3, child4, child5, child6) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent, child1);
                child2Setter(cachedParent).Add(child2);
                child3Setter(cachedParent).Add(child3);
                child4Setter(cachedParent).Add(child4);
                child5Setter(cachedParent).Add(child5);
                child6Setter(cachedParent).Add(child6);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static async Task<IEnumerable<TParent>> QueryOMMMMMAsync<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TChild6, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Action<TParent, TChild1> child1Setter,
            Func<TParent, IList<TChild2>> child2Setter,
            Func<TParent, IList<TChild3>> child3Setter,
            Func<TParent, IList<TChild4>> child4Setter,
            Func<TParent, IList<TChild5>> child5Setter,
            Func<TParent, IList<TChild6>> child6Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            await connection.QueryAsync<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TChild6, TParent>(sql, (parent, child1, child2, child3, child4, child5, child6) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent, child1);
                child2Setter(cachedParent).Add(child2);
                child3Setter(cachedParent).Add(child3);
                child4Setter(cachedParent).Add(child4);
                child5Setter(cachedParent).Add(child5);
                child6Setter(cachedParent).Add(child6);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static IEnumerable<TParent> QueryOOMMMM<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TChild6, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Action<TParent, TChild1> child1Setter,
            Action<TParent, TChild2> child2Setter,
            Func<TParent, IList<TChild3>> child3Setter,
            Func<TParent, IList<TChild4>> child4Setter,
            Func<TParent, IList<TChild5>> child5Setter,
            Func<TParent, IList<TChild6>> child6Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            connection.Query<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TChild6, TParent>(sql, (parent, child1, child2, child3, child4, child5, child6) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent, child1);
                child2Setter(cachedParent, child2);
                child3Setter(cachedParent).Add(child3);
                child4Setter(cachedParent).Add(child4);
                child5Setter(cachedParent).Add(child5);
                child6Setter(cachedParent).Add(child6);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static async Task<IEnumerable<TParent>> QueryOOMMMMAsync<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TChild6, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Action<TParent, TChild1> child1Setter,
            Action<TParent, TChild2> child2Setter,
            Func<TParent, IList<TChild3>> child3Setter,
            Func<TParent, IList<TChild4>> child4Setter,
            Func<TParent, IList<TChild5>> child5Setter,
            Func<TParent, IList<TChild6>> child6Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            await connection.QueryAsync<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TChild6, TParent>(sql, (parent, child1, child2, child3, child4, child5, child6) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent, child1);
                child2Setter(cachedParent, child2);
                child3Setter(cachedParent).Add(child3);
                child4Setter(cachedParent).Add(child4);
                child5Setter(cachedParent).Add(child5);
                child6Setter(cachedParent).Add(child6);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static IEnumerable<TParent> QueryOOOMMM<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TChild6, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Action<TParent, TChild1> child1Setter,
            Action<TParent, TChild2> child2Setter,
            Action<TParent, TChild3> child3Setter,
            Func<TParent, IList<TChild4>> child4Setter,
            Func<TParent, IList<TChild5>> child5Setter,
            Func<TParent, IList<TChild6>> child6Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            connection.Query<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TChild6, TParent>(sql, (parent, child1, child2, child3, child4, child5, child6) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent, child1);
                child2Setter(cachedParent, child2);
                child3Setter(cachedParent, child3);
                child4Setter(cachedParent).Add(child4);
                child5Setter(cachedParent).Add(child5);
                child6Setter(cachedParent).Add(child6);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static async Task<IEnumerable<TParent>> QueryOOOMMMAsync<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TChild6, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Action<TParent, TChild1> child1Setter,
            Action<TParent, TChild2> child2Setter,
            Action<TParent, TChild3> child3Setter,
            Func<TParent, IList<TChild4>> child4Setter,
            Func<TParent, IList<TChild5>> child5Setter,
            Func<TParent, IList<TChild6>> child6Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            await connection.QueryAsync<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TChild6, TParent>(sql, (parent, child1, child2, child3, child4, child5, child6) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent, child1);
                child2Setter(cachedParent, child2);
                child3Setter(cachedParent, child3);
                child4Setter(cachedParent).Add(child4);
                child5Setter(cachedParent).Add(child5);
                child6Setter(cachedParent).Add(child6);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static IEnumerable<TParent> QueryOOOOMM<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TChild6, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Action<TParent, TChild1> child1Setter,
            Action<TParent, TChild2> child2Setter,
            Action<TParent, TChild3> child3Setter,
            Action<TParent, TChild4> child4Setter,
            Func<TParent, IList<TChild5>> child5Setter,
            Func<TParent, IList<TChild6>> child6Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            connection.Query<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TChild6, TParent>(sql, (parent, child1, child2, child3, child4, child5, child6) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent, child1);
                child2Setter(cachedParent, child2);
                child3Setter(cachedParent, child3);
                child4Setter(cachedParent, child4);
                child5Setter(cachedParent).Add(child5);
                child6Setter(cachedParent).Add(child6);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static async Task<IEnumerable<TParent>> QueryOOOOMMAsync<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TChild6, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Action<TParent, TChild1> child1Setter,
            Action<TParent, TChild2> child2Setter,
            Action<TParent, TChild3> child3Setter,
            Action<TParent, TChild4> child4Setter,
            Func<TParent, IList<TChild5>> child5Setter,
            Func<TParent, IList<TChild6>> child6Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            await connection.QueryAsync<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TChild6, TParent>(sql, (parent, child1, child2, child3, child4, child5, child6) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent, child1);
                child2Setter(cachedParent, child2);
                child3Setter(cachedParent, child3);
                child4Setter(cachedParent, child4);
                child5Setter(cachedParent).Add(child5);
                child6Setter(cachedParent).Add(child6);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static IEnumerable<TParent> QueryOOOOOM<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TChild6, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Action<TParent, TChild1> child1Setter,
            Action<TParent, TChild2> child2Setter,
            Action<TParent, TChild3> child3Setter,
            Action<TParent, TChild4> child4Setter,
            Action<TParent, TChild5> child5Setter,
            Func<TParent, IList<TChild6>> child6Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            connection.Query<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TChild6, TParent>(sql, (parent, child1, child2, child3, child4, child5, child6) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent, child1);
                child2Setter(cachedParent, child2);
                child3Setter(cachedParent, child3);
                child4Setter(cachedParent, child4);
                child5Setter(cachedParent, child5);
                child6Setter(cachedParent).Add(child6);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static async Task<IEnumerable<TParent>> QueryOOOOOMAsync<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TChild6, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Action<TParent, TChild1> child1Setter,
            Action<TParent, TChild2> child2Setter,
            Action<TParent, TChild3> child3Setter,
            Action<TParent, TChild4> child4Setter,
            Action<TParent, TChild5> child5Setter,
            Func<TParent, IList<TChild6>> child6Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            await connection.QueryAsync<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TChild6, TParent>(sql, (parent, child1, child2, child3, child4, child5, child6) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent, child1);
                child2Setter(cachedParent, child2);
                child3Setter(cachedParent, child3);
                child4Setter(cachedParent, child4);
                child5Setter(cachedParent, child5);
                child6Setter(cachedParent).Add(child6);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static IEnumerable<TParent> QueryOOOOOO<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TChild6, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Action<TParent, TChild1> child1Setter,
            Action<TParent, TChild2> child2Setter,
            Action<TParent, TChild3> child3Setter,
            Action<TParent, TChild4> child4Setter,
            Action<TParent, TChild5> child5Setter,
            Action<TParent, TChild6> child6Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            connection.Query<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TChild6, TParent>(sql, (parent, child1, child2, child3, child4, child5, child6) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent, child1);
                child2Setter(cachedParent, child2);
                child3Setter(cachedParent, child3);
                child4Setter(cachedParent, child4);
                child5Setter(cachedParent, child5);
                child6Setter(cachedParent, child6);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }

        public static async Task<IEnumerable<TParent>> QueryOOOOOOAsync<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TChild6, TParentKey>(this IDbConnection connection, string sql,
            Func<TParent, TParentKey> parentKeySelector,
            Action<TParent, TChild1> child1Setter,
            Action<TParent, TChild2> child2Setter,
            Action<TParent, TChild3> child3Setter,
            Action<TParent, TChild4> child4Setter,
            Action<TParent, TChild5> child5Setter,
            Action<TParent, TChild6> child6Setter,
            dynamic param = null, IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null)
        {
            var cache = new Dictionary<TParentKey, TParent>();
            await connection.QueryAsync<TParent, TChild1, TChild2, TChild3, TChild4, TChild5, TChild6, TParent>(sql, (parent, child1, child2, child3, child4, child5, child6) =>
            {
                if (!cache.ContainsKey(parentKeySelector(parent)))
                    cache.Add(parentKeySelector(parent), parent);
                var cachedParent = cache[parentKeySelector(parent)];
                child1Setter(cachedParent, child1);
                child2Setter(cachedParent, child2);
                child3Setter(cachedParent, child3);
                child4Setter(cachedParent, child4);
                child5Setter(cachedParent, child5);
                child6Setter(cachedParent, child6);
                return cachedParent;
            }, param as object, transaction, buffered, splitOn, commandTimeout, commandType);
            return cache.Values;
        }
    }
}
