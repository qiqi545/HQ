#region LICENSE

// Unless explicitly acquired and licensed from Licensor under another
// license, the contents of this file are subject to the Reciprocal Public
// License ("RPL") Version 1.5, or subsequent versions as allowed by the RPL,
// and You may not copy or use this file in either source code or executable
// form, except in compliance with the terms and conditions of the RPL.
// 
// All software distributed under the RPL is provided strictly on an "AS
// IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, AND
// LICENSOR HEREBY DISCLAIMS ALL SUCH WARRANTIES, INCLUDING WITHOUT
// LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
// PURPOSE, QUIET ENJOYMENT, OR NON-INFRINGEMENT. See the RPL for specific
// language governing rights and limitations under the RPL.

#endregion

using System;
using System.Linq.Expressions;

namespace HQ.UI.Internal.Execution
{
	internal struct CoercedAwaitableInfo
	{
		public AwaitableInfo AwaitableInfo { get; }
		public Expression CoercerExpression { get; }
		public Type CoercerResultType { get; }
		public bool RequiresCoercion => CoercerExpression != null;

		public CoercedAwaitableInfo(AwaitableInfo awaitableInfo)
		{
			AwaitableInfo = awaitableInfo;
			CoercerExpression = null;
			CoercerResultType = null;
		}

		public CoercedAwaitableInfo(Expression coercerExpression, Type coercerResultType,
			AwaitableInfo coercedAwaitableInfo)
		{
			CoercerExpression = coercerExpression;
			CoercerResultType = coercerResultType;
			AwaitableInfo = coercedAwaitableInfo;
		}

		public static bool IsTypeAwaitable(Type type, out CoercedAwaitableInfo info)
		{
			if (AwaitableInfo.IsTypeAwaitable(type, out var directlyAwaitableInfo))
			{
				info = new CoercedAwaitableInfo(directlyAwaitableInfo);
				return true;
			}

			// It's not directly awaitable, but maybe we can coerce it.
			// Currently we support coercing FSharpAsync<T>.
			if (ObjectMethodExecutorFSharpSupport.TryBuildCoercerFromFSharpAsyncToAwaitable(type,
				out var coercerExpression,
				out var coercerResultType))
				if (AwaitableInfo.IsTypeAwaitable(coercerResultType, out var coercedAwaitableInfo))
				{
					info = new CoercedAwaitableInfo(coercerExpression, coercerResultType, coercedAwaitableInfo);
					return true;
				}

			info = default;
			return false;
		}
	}
}