using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using Xunit;
using Xunit.Abstractions;
using Blowdart.UI.Internal;

namespace Blowdart.UI.Tests
{
	public class CodeGeneration
	{
		private const string BlockElements = @"<address><article><aside><blockquote><canvas><dd><div><dl><dt><fieldset><figcaption><figure><footer><form><h1><h2><h3><h4><h5><h6><header><hr><li><main><nav><noscript><ol><p><pre><section><table><tfoot><ul><video>";
		private const string InlineElements = @"<a><abbr><acronym><b><bdo><big><br><button><cite><code><dfn><em><i><img><input><kbd><label><map><object><output><q><samp><script><select><small><span><strong><sub><sup><textarea><time><tt><var>";

		private readonly ITestOutputHelper _console;

		public CodeGeneration(ITestOutputHelper console)
		{
			_console = console;
		}

		[Fact]
		public void Generate_inline_elements()
		{
			var sb = new StringBuilder();
			sb.AppendLine("// <auto-generated />");
			sb.AppendLine();
			sb.AppendLine("// Copyright (c) Blowdart, Inc. All rights reserved.");
			sb.AppendLine("// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.");
			sb.AppendLine();
			sb.AppendLine("// ReSharper disable InconsistentNaming");
			sb.AppendLine("// ReSharper disable CheckNamespace");
			sb.AppendLine();
			sb.AppendLine("// <auto-generated />");
			sb.AppendLine("public static partial class HtmlElementExtensions");
			sb.AppendLine("{");
			foreach (Match match in Regex.Matches(InlineElements, "<\\w+>", RegexOptions.Compiled | RegexOptions.IgnoreCase | RegexOptions.Singleline))
			{
				var element = match.Value.TrimStart('<').TrimEnd('>');

				sb.AppendLine();
				sb.AppendLine($"\tpublic static string @{element}(string value)");
				sb.AppendLine($"\t{{");
				sb.AppendLine($"\t\treturn $\"<{element}>{{value}}</{element}>\";");
				sb.AppendLine($"\t}}");
			}
			sb.AppendLine("}");
			
			_console.WriteLine(sb.ToString());
		}

		[Fact]
		public void Generate_element_method_extensions()
		{
			var map = GenerateAttributeMap();

			var sb = new StringBuilder();
			sb.AppendLine("// <auto-generated />");
			sb.AppendLine();
			sb.AppendLine("// Copyright (c) Blowdart, Inc. All rights reserved.");
			sb.AppendLine("// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.");
			sb.AppendLine();
			sb.AppendLine("using System;");
			sb.AppendLine();
			sb.AppendLine("namespace Blowdart.UI.Web");
			sb.AppendLine("{");
			sb.AppendLine();
			sb.AppendLine("\tpublic static partial class HtmlExtensions");
			sb.AppendLine("\t{");

			GenerateElementMethods(BlockElements, true, map, sb);
			GenerateElementMethods(InlineElements, true, map, sb);

			sb.AppendLine("\t}");
			sb.AppendLine("}");

			_console.WriteLine(sb.ToString());
		}

		private static void GenerateElementMethods(string elements, bool blocks, Dictionary<string, List<KeyValuePair<string, Type>>> map, StringBuilder sb)
		{
			var matches = Regex.Matches(elements, "<\\w+>", RegexOptions.Compiled | RegexOptions.IgnoreCase | RegexOptions.Singleline);
			for (var i = 0; i < matches.Count; i++)
			{
				var match = matches[i];
				var element = match.Value.TrimStart('<').TrimEnd('>');
				var elementName = char.ToUpperInvariant(element[0]) + element.Substring(1);

				var qsb = new StringBuilder();

				var names = new HashSet<string>();
				var parameters = new List<KeyValuePair<string, Type>>();

				if (map.TryGetValue(element, out var value))
				{
					foreach (var entry in value)
						names.Add(entry.Key);
					parameters.AddRange(value);
				}

				if (map.TryGetValue("*", out value))
				{
					foreach (var entry in value)
						names.Add(entry.Key);
					parameters.AddRange(value);
				}

				parameters.Sort((x, y) => string.Compare(x.Key, y.Key, StringComparison.Ordinal));
				AppendAttributeParameters(parameters, qsb);

				var qualified = qsb.ToString();

				sb.AppendLine();
				sb.AppendLine($"\t\t#region {element}");

				if (blocks)
				{
					//
					// Qualified Declaration:
					sb.AppendLine();
					sb.AppendLine($"\t\tpublic static Ui Begin{elementName}(this Ui ui, {qualified})");
					sb.AppendLine($"\t\t{{");
					sb.AppendLine($"\t\t\treturn ui.BeginElement(\"{element}\", new {{ {string.Join(", ", names)} }});");
					sb.AppendLine($"\t\t}}");

					//
					// Anonymous Declaration:
					sb.AppendLine();
					sb.AppendLine($"\t\tpublic static Ui Begin{elementName}(this Ui ui, object attr = null)");
					sb.AppendLine($"\t\t{{");
					sb.AppendLine($"\t\t\treturn ui.BeginElement(\"{element}\", attr);");
					sb.AppendLine($"\t\t}}");

					//
					// Inline Declaration:
					sb.AppendLine();
					sb.AppendLine($"\t\tpublic static Ui Begin{elementName}(this Ui ui, params object[] attributes)");
					sb.AppendLine($"\t\t{{");
					sb.AppendLine($"\t\t\treturn ui.BeginElement(\"{element}\", attributes);");
					sb.AppendLine($"\t\t}}");

					//
					// End:
					sb.AppendLine();
					sb.AppendLine($"\t\tpublic static Ui End{elementName}(this Ui ui)");
					sb.AppendLine($"\t\t{{");
					sb.AppendLine($"\t\t\treturn ui.EndElement(\"{element}\");");
					sb.AppendLine($"\t\t}}");
				}

				//
				// InnerText Declaration:
				sb.AppendLine();
				sb.AppendLine($"\t\tpublic static Ui {elementName}(this Ui ui, string innerText, object attr = null)");
				sb.AppendLine($"\t\t{{");
				sb.AppendLine($"\t\t\treturn ui.Element(\"{element}\", innerText, attr);");
				sb.AppendLine($"\t\t}}");

				//
				// Empty Declaration:
				sb.AppendLine();
				sb.AppendLine($"\t\tpublic static Ui {elementName}(this Ui ui, object attr)");
				sb.AppendLine($"\t\t{{");
				sb.AppendLine($"\t\t\treturn ui.Element(\"{element}\", null, attr);");
				sb.AppendLine($"\t\t}}");

				//
				// Scoped:
				sb.AppendLine();
				sb.AppendLine($"\t\t/// <summary> This call is equivalent to: \r\n\t\t///\t<code>\r\n\t\t///\t\tui.Begin{elementName}();\r\n\t\t///\t\taction();\r\n\t\t///\t\tui.End{elementName}();\r\n\t\t///\t</code>\r\n\t\t/// </summary>");
				sb.AppendLine($"\t\tpublic static Ui {elementName}(this Ui ui, Action action)");
				sb.AppendLine($"\t\t{{");
				sb.AppendLine($"\t\t\treturn ui.Element(\"{element}\", action);");
				sb.AppendLine($"\t\t}}");
				sb.AppendLine();
				sb.AppendLine($"\t\t/// <summary> This call is equivalent to: \r\n\t\t///\t<code>\r\n\t\t///\t\tui.Begin{elementName}(attr);\r\n\t\t///\t\taction();\r\n\t\t///\t\tui.End{elementName}();\r\n\t\t///\t</code>\r\n\t\t/// </summary>");
				sb.AppendLine($"\t\tpublic static Ui {elementName}(this Ui ui, object attr, Action action)");
				sb.AppendLine($"\t\t{{");
				sb.AppendLine($"\t\t\treturn ui.Element(\"{element}\", attr, action);");
				sb.AppendLine($"\t\t}}");
				sb.AppendLine();
				sb.AppendLine($"\t\t/// <summary> This call is equivalent to: \r\n\t\t///\t<code>\r\n\t\t///\t\tui.Begin{elementName}();\r\n\t\t///\t\taction(ui);\r\n\t\t///\t\tui.End{elementName}();\r\n\t\t///\t</code>\r\n\t\t/// </summary>");
				sb.AppendLine($"\t\tpublic static Ui {elementName}(this Ui ui, Action<Ui> action)");
				sb.AppendLine($"\t\t{{");
				sb.AppendLine($"\t\t\treturn ui.Element(\"{element}\", action);");
				sb.AppendLine($"\t\t}}");
				sb.AppendLine();
				sb.AppendLine($"\t\t/// <summary> This call is equivalent to: \r\n\t\t///\t<code>\r\n\t\t///\t\tui.Begin{elementName}(attr);\r\n\t\t///\t\taction(ui);\r\n\t\t///\t\tui.End{elementName}();\r\n\t\t///\t</code>\r\n\t\t/// </summary>");
				sb.AppendLine($"\t\tpublic static Ui {elementName}(this Ui ui, object attr, Action<Ui> action)");
				sb.AppendLine($"\t\t{{");
				sb.AppendLine($"\t\t\treturn ui.Element(\"{element}\", attr, action);");
				sb.AppendLine($"\t\t}}");
				sb.AppendLine();

				sb.AppendLine($"\t\t#endregion");
			}
		}

		private static void AppendAttributeParameters(IEnumerable<KeyValuePair<string, Type>> value, StringBuilder sb)
		{
			var list = value.ToList();
			for (var i = 0; i < list.Count; i++)
			{
				var entry = list[i];
				var (key, type) = entry;

				if (i != 0)
					sb.Append(", ");

				var typeName = type.GetPreferredTypeName();

				sb.Append(typeName);
				sb.Append(' ');
				sb.Append(NormalizeKey(key));
				sb.Append(Nullable.GetUnderlyingType(type) != null ? " = null" : $" = default({typeName})");
			}
		}

		// reference: https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes
		// reference: https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes
		public Dictionary<string, List<KeyValuePair<string, Type>>> GenerateAttributeMap()
		{
			// TODO strong typing "type"?
			// TODO IDL validation? (type=foo => type=text)
			// TODO data-*
			
			var map = new Dictionary<string, List<KeyValuePair<string, Type>>>();

			//
			// Boolean Attributes:
			foreach (var line in @"
contenteditable:*
draggable:*
checked:command,input
controls:audio,video
disabled:button,command,fieldset,input,keygen,optgroup,option,select,textarea
formnovalidate:button
loop:audio,bgsound,marquee,video
muted:audio,video
open:details
readonly:input,textarea
reversed:ol
wrap:textarea
".Split(new[] { Environment.NewLine }, StringSplitOptions.RemoveEmptyEntries))
			{
				var tokens = line.Split(":");
				var attributeName = NormalizeKey(tokens[0]);
				var affectedElements = tokens[1].Split(",", StringSplitOptions.RemoveEmptyEntries);

				foreach (var element in affectedElements)
				{
					if(!map.TryGetValue(element, out var list))
						map.Add(element, list = new List<KeyValuePair<string, Type>>());

					list.Add(new KeyValuePair<string, Type>(attributeName, typeof(bool)));
				}
			}

			//
			// Global Attributes:
			foreach (var line in @"
accesskey
autocapitalize
class
contextmenu
dir
dropzone
hidden|bool
id
itemprop
lang
slot
spellcheck
style
tabindex|int?
title
translate
".Split(new[] { Environment.NewLine }, StringSplitOptions.RemoveEmptyEntries))
			{
				var tokens = line.Split("|", StringSplitOptions.RemoveEmptyEntries);
				var attributeName = NormalizeKey(tokens[0]);

				var type = typeof(string);
				if (tokens.Length > 1)
					type = GetAttributeType(tokens);

				if (!map.TryGetValue("*", out var list))
					map.Add("*", list = new List<KeyValuePair<string, Type>>());

				list.Add(new KeyValuePair<string, Type>(attributeName, type));
			}

			//
			// Element-Specific Attributes:
			foreach (var line in @"
accept:form,input
accept-charset:form
action:form,
align:applet,caption,col,colgroup,hr,iframe,img,table,tbody,td,tfoot,th,thead,tr
allow:iframe
alt:applet,area,img,input
async:script
autocomplete:form,input,textarea
autofocus:button,input,keygen,select,textarea
autoplay:audio,video
buffered:audio,video
challenge:keygen
charset:meta,scripts
cite:blockquote,del,ins,q
code:applet
codebase:applet
color:basefont,font,hr
cols:textarea
colspan:td,th
content:meta
coords:area
crossorigin:audio,img,link,script,video
csp:iframe
data:object
datetime:del,ins,time
decoding:img
default:track
defer:script
dirname:input,textarea,
download:a,area
enctype:form
enterkeyhint:textarea
for:button,fieldset,input,keygen,label,meter,object,output,progress,select,textarea
formaction:input,button
headers:td,th
height:canvas,embed,iframe,img,input,object,video
high:meter
href:a,area,base,link
hreflang:a,area,link
http-equiv:meta
icon:command
importance:iframe,img,link,script
integrity:link,script
intrinsicsize:img
inputmode:textarea,contenteditable
keytype:keygen
kind:track
label:track
language:script
loading:img,iframe
list:input
low:meter
manifest:html
max:input,meter,progress
maxlength:input,textarea
minlength:input,textarea
media:a,area,link,source,style
method:form
min:input,meter
multiple:input,select
name:button,form,fieldset,iframe,input,keygen,object,output,select,textarea,map,meta,param
novalidate:form
optimum:meter
pattern:input
ping:a,area
placeholder:input,textarea
poster:video
preload:audio,video
radiogroup:command
referrerpolicy:a,area,iframe,img,link,script
rel:a,area,link
required:input,select,textarea
rows:textarea
rowspan:td,th
sandbox:iframe
scope:th
scoped:style
selected:option
shape:a,area
size:input,select
sizes:link,img,source
span:col,colgroup
src|Uri:audio,embed,iframe,img,input,script,source,track,video
srcdoc:iframe
srclang:track
srcset:img,source
start:ol
step:input
summary:table
target:a,area,base,form
type:button,input,command,embed,object,script,source,style,menu
usemap:img,input,object
value:button,data,input,li,meter,option,progress,param
width:canvas,embed,iframe,img,input,object,video
".Split(new[] { Environment.NewLine }, StringSplitOptions.RemoveEmptyEntries))
			{
				var tokens = line.Split(":");
				var attributeName = NormalizeKey(tokens[0]);

				var meta = attributeName.Split("|", StringSplitOptions.RemoveEmptyEntries);
				var type = typeof(string);
				if (meta.Length > 1)
				{
					type = GetAttributeType(meta);
					attributeName = NormalizeKey(meta[0]);
				}

				var affectedElements = tokens[1].Split(",", StringSplitOptions.RemoveEmptyEntries);

				foreach (var element in affectedElements)
				{
					if (!map.TryGetValue(element, out var list))
						map.Add(element, list = new List<KeyValuePair<string, Type>>());

					list.Add(new KeyValuePair<string, Type>(attributeName, type));
				}
			}

			return map;
		}

		private static string NormalizeKey(string key)
		{
			switch (key)
			{
				case "checked":
				case "readonly":
				case "class":
				case "for":
					key = $"@{key}";
					break;
			}

			// accept-charset = acceptCharset
			var words = key.Split('-');
			if (words.Length == 1)
				return words[0];

			var pascal = string.Concat(words.Select(x => char.ToUpperInvariant(x[0]) + x.Substring(1)));
			return char.ToLowerInvariant(pascal[0]) + pascal.Substring(1);
		}

		private static Type GetAttributeType(IReadOnlyList<string> tokens)
		{
			var typeName = tokens[1];

			switch (typeName)
			{
				case "bool":
					return typeof(bool);
				case "bool?":
					return typeof(bool?);
				case "int":
					return typeof(int);
				case "int?":
					return typeof(int?);
				case "Uri":
					return typeof(Uri);
				default:
					throw new Exception("derp");
			}
		}
	}
}
